\documentclass[a4paper,11pt,twoside]{article}%pridat twoside, do [] pre obojstrannu tlac
    \pagestyle{headings}
    %\linespread{1.15} % riadkovanie
    \usepackage[top=2.5cm, bottom=2.5cm, left=3.5cm, right=2cm]{geometry} %odporucane okraje
%    \usepackage[top=2.9cm, bottom=2.9cm, left=2.5cm, right=4cm]{geometry} %okraje
    %\evensidemargin=-0cm       %uprava okrajov
    %\oddsidemargin=+1.5cm        %uprava okrajov

%Slovencina
\usepackage[slovak]{babel}
\usepackage[utf8x]{inputenc}
%\usepackage[cp1250]{inputenc}
%\usepackage[T1]{fontenc} %pekne makcene


%male popisy obrazkov a~grafika
\usepackage[font=small,margin=0.5cm]{caption} % margin reguluje okraje popisu obrazka (v pripade, ze je na sirku strany a~ma viac ako 1 riadok)
\usepackage[dvips]{graphicx}
\usepackage{wrapfig}
\usepackage[usenames,dvipsnames]{color}
\usepackage{epstopdf}   %bez tohto pdflatex nezoberie eps obazky

%grid obrazkov
\usepackage{subfig}

%farebne tabulky
\usepackage{colortbl}
\usepackage[table]{xcolor}
%na otacanie tabuliek
\usepackage{rotating}

%odsadenie prveho odstavca
\usepackage{indentfirst}

%Matematicke vyrazy
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{verbatim}
\usepackage[official]{eurosym}
\usepackage{url}

%algoritmy
\usepackage[lined,boxed]{algorithm2e}

%�moje definicie
\newcommand{\p}{\partial}
 \def\epsilon{\varepsilon}
 \def\Bf#1{\mathbf{#1}}

%Slovenske uvodzovky
\chardef\clqq=18 \sfcode18=0
\chardef\crqq=16 \sfcode16=0
\def\uv#1{\clqq#1\crqq}

\usepackage{verse}

\author{Mária Somorovská}
\title{Automatické segmentačné metódy biologických dát}

%Hyperreferencia
\usepackage{hyperref}
    \hypersetup{colorlinks,citecolor=red,filecolor=black,linkcolor=blue,urlcolor=blue,pdftex}
%====================================================================================================================================================
%====================================================================================================================================================

\begin{document}
\setlength{\belowdisplayskip}{7pt} \setlength{\belowdisplayshortskip}{5pt}
\setlength{\abovedisplayskip}{7pt} \setlength{\abovedisplayshortskip}{5pt}

%***********************zaciatok prvej strany
    \thispagestyle{empty}
    {
    \topmargin=0pt
    \centerline {\large \bf{SLOVENSKÁ TECHNICKÁ UNIVERZITA V~BRATISLAVE}}
    \vskip 0.2cm
    \centerline{\large \bf{STAVEBNÁ FAKULTA}}
    \vskip 7cm
    \centerline{\Large \bf{Automatické segmentačné metódy biologických dát}}
    \vskip 0.2cm
    %\centerline{\Large \bf{V PRÍPADE, ŽE JE PRIDLHÝ JEHO DRUHÝ RIADOK}}
    %\centerline{ \bf{(verzia z~\today) }}   %vypisovanie dnesneho datumu
    \vskip 0.5cm
    \centerline{\large \bf{Diplomová práca}}
    \vskip 5cm          %\vskip 2cm             %zmena kvoli zobrazovaniu dnesneho datumu
    \normalsize
        \begin{tabular}[l]{p{0.27\textwidth}p{0.73\textwidth}}
        Študijny program: & Matematicko-počítačové modelovanie\\
        Študijny odbor: & Aplikovaná matematika\\
        Školiace pracovisko: & Katedra matematiky a deskriptívnej geometrie\\
        Vedúci diplomovej práce: & doc. RNDr. Zuzana Krivá, PhD. \\
        \end{tabular}
    \vskip 1.5cm
    \centerline{\large \bf{BRATISLAVA 2020}}
    \vskip 0.2cm
    \centerline{\large \bf{Bc. Mária Somorovská}}
    }
\pagebreak
%**********************************koniec prvej strany

%obsah
\tableofcontents

\newpage

\section{Úvod}
% In the different 
%Spracovanie obrazov, je metóda, ktorá používa rôzne operácie na obrazových dátach

%Makrofág je typ pohyblivej bielej krvinky, ktorá hrá dôležitú úlohu v ochrane imunitného systému  

%Dáta, ktorými sa zaoberá táto 
%Rôzne vedné odvetvia, využivajú

V rôznych vedných disciplínach ale aj v bežnom živote sa používajú rôzne aplikácie spracovania obrazov. Spracovanie obrazov je metóda, ktorá pomocou rôznych matematických operácii a algoritmov upravuje obrazové dáta rôznych formátov a pomáha z nich získavať užitočné informácie. Obrazové dáta je potrebné zobraziť, či už pred alebo po modifikácií. 

Cieľom práce je vytvorenie softvéru, ktorý slúži na vizualizáciu a segmentáciu obrazov získaných konfokálnym laserovým mikroskopom, konkrétne sa jedná o biologické dáta a to obrazy makrofágov. Takéto dáta môžu obsahovať šum, ktorý je potrebné odstrániť pre lepšie rozoznanie objektov na dátach. 
 
Z biologického hľadiska, je maktofág typ bielej krvinky, ktorá hrá dôležitú úlohu pri ochrane imunitného systému a homeostázy. Avšak disfunkčné makrofágy menia svoje účinky a u ľudí môžu spôsobovať závažné ochorenia ako sú napríklad  zaápalové ochorenia, ktoré vediú k častým infekciám alebo sa môžu podielať na postupe rakoviny. Makrofág mení svoj tvar keď sa približuje smerom k rane. Táto zmena tvaru je spôsobená objektami, ktoré sa nachádzajú v blízkosti makrofágu, ako napríklad tkanivovými bunkami alebo medzibunkovou hmotou.
Segmentácia obrazov môže byť užitočným nástrojom na porozumenie spôsobu interakcie medzi makrofágmi a bunkami, ktoré ho obklopujú, avšak takáto segmentácia môže byť náročnou úlohou, kvôli ich nepravidelnému tvaru.

Mikroskopové dáta makrofágov, s ktorými pracujeme v tejto práci, sú makrofágy priesvitného embrya zebricky pruhovanej (\textit{lat.} danio rerio). Táto larva bola poranená a cytoplazmy makrofágov sú zafarbené zeleným svetielkujúcim proteínom (kaede) pre lepšiu viditeľnosť pod mikroskopom. Pôvodné dáta makrofágov sú získané v časovom úseku 5 hodín a s časovým krokom 4 minúty. Následne dané trojdimenzionálne obrazové dáta sú premietnuté do roviny za použitia maximálnej intenziy približne zo 70 rezov, z ktorých vzniknú dvojdimenzionálne obrazové dáta. 
%vo formáte tiff.

V tejto práci sa zaoberáme časťami/výrezmi takýchto dát, na ktorých sa nachádza jeden makrofág a používame rôzne metódy na segmentáciu, buď automatické alebo semi-automatické. Softvér by mal byť intuitívny, a teda určený aj užívateľom, ktorí implementovaným algoritmom nemusia rozumieť. 
  
Práca je rozdelená do viacerých častí, v ktorých je podrobnejšie popísaná funkcionalita programu spolu s užívateľským prostredím, použitými algoritmami, knižnicami.

Prvá časť je teoretická a venuje sa matematikým algoritmom využitých pri implementácii, založených na poznatkoch zo spracovania obrazov. Jedná sa o niekoľko automatických a semi-automatických segmentačných metód, ktoré sú kombináciou prahovacích metód a segmentačnej metódy subjektívnych plôch(SUBSURF).

Druhá časť sa zameriava na technológie a knižnice využité pri implementácii. Nachádza sa tam popis Qt knižníc, ktoré boli použité pri vytváraní užívateľského prostredia, VTK knižníc, ktoré boli využité na zobrazenie a manipuláciu s dátami. Popísané sú tu aj triedy, ktoré boli v programe najviac využité.

Ďaľšia časť sa zaoberá popisom grafického rozhrania programu, ktorá by mohla slúžiť aj ako manuál slúžiaci užívateľovi pri používaní.

V poslednej časti sa nachádzajú výsledky, ku ktorým sme v práci dospeli a porovnania medzi rôznymi automatickými a semi-automatickými segmentačnými metódami.

% užité matematické algoritmy, funkcionalita naimplementovaného softvéru a 
  
 
%Skúmané dáta pochadzajú pôvodne z  a sú z

%\newpage

\section{Segmentácie obrazov}

%

Hlavnou úlohou pri segmentácii makrofágov, je rozlíšenie pozadia a objektu na obrazových dátach. Táto úloha môže byť sťažená kvôli strate intenzity na hranách alebo šumu, ktorý sa môže na dátach nachádzať.

%Hlavnou úlohou pri segmentácii makrofágov je odstránenie šumu, ktorý môže byť spôsobený premietnutím dát z trojdimenzionálneho priestoru do roviny alebo bunkami nachádzajúcimi sa v okolí makrofágu alebo zmenou tvaru v čase.

Segmentácia takýchto dát je náročnou úlohou pretože makrofágy majú nepravidelné tvary s meniacou sa intenzitou, ktoré sa ťažko spracovávajú. Preto sme vybrali niekoľko druhov prahovacích metód, ktoré sme skombinovali spolu s metódou segmentácie subjektívnych plôch a aplikovali sme ich na testované dáta.

\subsection{Globálne prahovanie}

 Úlohou globálnych ptahovacích metód je nájsť jedinú optimálnu prahovú hodnotu $q$, v našom prípade šedotónových obrazových dát, ktorá zadefinuje každý pixel obrazu buď do popredia (ako objekt na dátach) alebo ako pozadie. Mnohé z týchto metód sú založené na histograme. Teda všetky pixely sú zatriedené do dvoch disjunktných množín $C_0$ a $C_1$, kde množina $C_0$ obsahuje všetky pixle nachádzajúce sa medzi hodntami $(0, 1, \dots , q)$ a $C_1$ obsahuje všetky zvyšné pixle nachádzajúce sa na intervale $(q+1, \dots , K-1)$, teda

\begin{equation*}
(u, v) \in \begin{cases} C_0 & \text{ak} \hspace{1em} I(u,v) \leq q \hspace{1em} \text{(pozadie)} \\  C_1 & \text{ak} \hspace{1em} I(u,v) \geq q \hspace{1em} \text{(objekt)} \end{cases}.
\end{equation*}

%preformulovat
Treba si uvedomiť, že tieto hodnoty závisia od toho, či je pozadie bledé a objekt tmavý alebo naopak.

Prahovacie metódy založené na histograme sú zvyčajne jednoduché a účinné, pretože pracujú s malým množstvom dát. V našom prípade sa jedná o 256 odtieňov sivej/šede. Dajú sa rozdeliť na 2 hlavné kategórie: štatistické metódy a také, ktoré sú založené na tvare.


\subsubsection{Otsuho metóda}
Otsuho metóda patrí medzi automatické  prahovacie metódy, ktorá rozdeľuje obrazové dáta na 2 rôzne triedy pomocou prahu $q$ $-$ na objekt a pozadie. Hlavnou myšlienkou tejto metódy je nájsť prah $q$ taký, že výsledné distribúcie tried sú čo najlepšie oddelené, čo znamená, že príslušné histogramy majú čo najmenší rozptyl(sú čo njužšie). Na výpočet prahu $q$ sa používa metóda známa ako vnútro$-$triedna variancia(within class variance), kde sa pomocou tohoto výpočtu hľadá minimum. V tomto prípade sa dá ukázať, že táto úloha môže byť zmenená na maximalizačnú úlohu, tiež známu ako medzi$-$triedna variancia(between class variance), ktorá je výpočtovo menej náročná, keďže sú spracovávané len šedotónové obrazové dáta. Ak by išlo o farebný RGB obaz, musel by byť rozdelený na jednotlivé intenzity a výsledkom by bolo viac prahových hodnôt $(q_1, \ldots, q_n)$, kde $n$ reprezentuje počet intenzít v danom obraze.

Nech $K$ je maximálna intenzita obrazu a hodnoty normalizovaného histogramu, budú vypočítané ako
%\begin{equation*}
%p_i^c = \frac{h_i^c}{N}, \hspace{10mm}  \sum_{i=1}^{N} p_i^c = 1, \hspace{10mm} c = \begin{cases} 1, 2, 3 & \text{pre farebné obrazy} \\ 1 & \text{pre čiernobiele obrazy} \end{cases},
%\end{equation*}

\begin{equation*}
p_i = \frac{h_i}{N}, \hspace{10mm}  \sum_{i=1}^{N} p_i = 1,
\end{equation*}

kde $i$ je konkrétny level intenzity $(0 \leq i \leq K)$, $N$ je celkový počet pixelov na obraze, $h_i$ predstavuje histogram. 
Keďže v našom prípade máme len 2 triedy $C_0$ a $C_1$ a vzniknutý histogram sa tiež nazýva bimodálnym.

Na definíciu tried $C_0$ a $C_1$ je potrebné vypočítať stredné hodnoty $\mu_0$ a $\mu_1$ definované ako

\begin{equation*}
\mu_0 =  \sum_{i=1}^{q}\frac{i p_i}{\omega_0(q)}, \hspace{10mm} \mu_1 =  \sum_{i=q + 1}^{K}\frac{i p_i}{\omega_1(q)},
\end{equation*}

kde $\omega_0(q)$ a $\omega_1(q)$ sú rozdelenia pravdepodobnosti pre triedy $C_0$ a $C_1$. Teraz môžeme zadefiovať rozptyl pre obe triedy

\begin{equation*}
\sigma_0 = \omega_0(\mu_0 + \mu_T), \hspace{10mm} \sigma_1 =  \omega_1(\mu_1 + \mu_T),
\end{equation*}

kde $ \mu_T = \omega_0\mu_0 + \omega_1\mu_1$. Následne zadefinujeme Otsuho medzi$-$triednu varianciu ako

\begin{equation*}
\sigma^2 = \sigma_0 + \sigma_1.
\end{equation*}

%Preto v prípade, že je histogram bimodálny, tak budú existovať len dve triedy a objekt na obraze bude vysegmentovaný takmer dokonale.
Z hodnoty medzi$-$triednej variancie, pomocou maximalizácie rozptylu medzi pozadím a objektom v histograme, nájdeme optimálny prah $q^*$, ktorý je definovaný ako
%Optimálny prah $q^*$ nájdeme cez maximalizáciu rozptylu medzi pozadím a objektom v histograme pomocou medzi$-$triednej variancie, ktorá je definovaná ako

\begin{equation*}
\sigma^2(q*) = \max_{1 \leq q < K} \sigma^2_1(q),
\end{equation*}

kde $\sigma$ označuje rozptyl a $K$ je maximálna intenzita obrazu.

Otsuho metóda dokáže dobre rozlíšiť dáta s makrofágmi, v prípade že dáta neobsahujú výrazný šum aj v prípade keď sa na dátach nachádzajú tenké časti alebo sú zložito tvarované. Avšak ak je intenzita šumu pozadia porovnateľná s intenzitou, táto metóda môže spôsobiť rozdelenie objektu a stratiť niektoré časti objektu, keďže je do úvahy braná len intenzita obrazu.

%predpokladá, že originálne obrazové dáta obsahujú dáta z dvoch
%rôznych pixelvých tried, kde rozdelenie intenzít nie je známe. Cieľom tejto metódy je nájsť prah $q$, ktorý rozdelí dáta na popredie(objekt) a pozadie.
%% tak aby distribúcie boli maximálne oddelené. To znamená:
%Základn 
%\begin{itemize}
%\item
%\item
%\end{itemize}

%The goal is to find a threshold q such that the resulting background and foreground
%distributions are maximally separated, which means that they are (a) each as
%narrow as possible (have minimal variances) and (b) their centers (means) are
%most distant from each other.
%For a given threshold q, the variances of the corresponding background and
%foreground partitions can be calculated straight from the image’s %histogram(see
%Eqn. (2.11)–(2.12)). The combined width of the two distributions is measured
%by the within-class variance

\subsubsection{Prahovanie pomocou maximálnej entropie}

Entropia je dôležitým pojmom v teórii informácií a najmä pri kompresii dát. Je to štatistická miera, ktorá kvantifikuje priemerné množstvo informácií obsiahnutých v  "správe" \\ obsahujúce stochasticky generované dáta. Entropia je definovaná ako

\begin{equation*}
H(I)= -\sum_{u,v} p(g)log_b(p(g)),
\end{equation*}

kde $g$ je intenzita v pixli u,v, $p(g)$ je pravdepodobnst intenzity v normalizovanom histograme, $b$ je logaritmický základ, ktorý zvolíme buď $b=10$ alebo $b=e$ aby boli dosiahnuté čo najlepšie výsledky. Hodnota entropie $H$ bude vždy nadobúdať kladnú hodnotu, pretože argument logaritmu, sú pravdepodobnosti, ktoré patria intervalu $(0,1)$ z čoho vyplýva že hodnotaa logaritmu bude vzdy zaporna. %SKONTROOLOVAT

Z dôvodu hľadania maximálnej hodnoty entropie, potrebujeme definovať entropie pre každú triedu

%\begin{equation*}
%\begin{array}{l}
\begin{equation*}
H_0(q) =  -\frac{1}{P_0(q)}S_0(q)+log(P_0(q)) \\
\end{equation*}
\begin{equation*}
H_1(q) =  -\frac{1}{1-P_0(q)}S_1(q)+log(1-P_0(q)),
\end{equation*}
%\end{array}
%\end{equation*}
kde $P_0$ predstavuje kumulatívnu pravdepodobnosť a $S_0$, $S_1$ sú sumačné podmienky. 
Kumulatívna pravdepodobnosť $P_0$ je definovaná ako
\begin{equation*}
	P_0(q) = \begin{cases} p(0) & \text{pre } q = 0 \\
                            P_0(q-1) + p(q)         & \text{pre } 0 < q < K ,     %
        \end{cases}
 \end{equation*} 
a sumačné podmienky $S_0$, $S_1$ sú predpočítané a definované ako
 \begin{equation*}   
    S_0(q) = \begin{cases} p(0).log(p(0))) & \text{pre } q = 0 \\
                            S_0(q-1) + p(q)log(p(q))         & \text{pre } 0 < q < K      
        \end{cases}
        \end{equation*}
\begin{equation*}
	S_1(q) = \begin{cases} 0 & \text{pre } q = L-1 \\
                            S_0(q+1) + p(q+1)log(p(q+1))         & \text{pre } 0 \leq q < K -1      %
        \end{cases}       	 
\end{equation*}

Táto metóda je jednoduchá a účinná, pretože závisí len od histogarmu obrazu. %Zosegmentované dáta môžu 
Tiez znama ako Kapurova (strana 20 je tam poznamka)
*PRIDAT AKO SA RATA CELKOVA ENTROPIA + *

\subsection{Lokálne adaptívne prahovanie}

Lokálne adaptívne prahovanie namiesto jednej prahovej hodnoty pre celý obraz, používa adaptívne prahovanie, ktoré určuje meniacu sa prahovú hodnotu $Q(u,v)$ pre každú polohu obrazu. Tieto hodoty zodpovedajú každému pixelu $I(u,v)$ zodpovedajúcemu danému obrazu. Nasledujúce metódy sa líšia iba s ohľadom na to, akým spôsobom sú získané prahy $Q$ zo vstupného obrázku. 

\subsubsection{Bernsenova metóda}

Táto metóda, určuje prah dynamicky pre každú polohu na obraze $(u,v)$, založená na minimálnej a maximálnej intenzite nachádzajúcej sa v okolí $R(u,v)$. Ak 
\begin{equation}
\begin{array}{l}
I_{min}(u,v) = \min\limits_{(i,j)\in R(u,v)} I(i,j),  \\
I_{max}(u,v) = \max\limits_{(i,j)\in R(u,v)} I(i,j),
\end{array}
\end{equation}

sú minimálnou a maximálnou hodnotou intenzity, na nejakom fixne danom okolí $R$ so stredom na pozícií $(u,v)$. Prahovú hodnotu dostaneme pomocou aritmetického priemeru nájdeneho minima a maxima daného okolia 

\begin{equation}
Q(u,v) \gets \frac{I_{min}(u,v) + I_{max}(u,v)}{2}
\end{equation}

Táto operácia sa vykonáva tak dlho, až pokým lokálny kontrast $c(u, v) = I_{max}(u, v) − I_{min}(u, v)$ sa nachachádza nad preddefinovaným limtom $c_{min}$. Ak $c(u, v) < c_{min}$, tak pixle..

*DOPISAT*
%This is done as long as the local contrast c(u, v) = Imax(u, v)−Imin(u, v) is above
%some predefined limit cmin. If c(u, v) < cmin, the pixels in the corresponding
%image region are assumed to belong to a single class and are (by default)
%assigned to the background.
%The whole process is summarized in Alg. 2.7. The main function provides
%a control parameter bg to select the proper default threshold ¯q, which is set to
%K in case of a dark background (bg = dark) and to 0 for a bright background
%(bg = bright). The support region R may be square or circular, typically with
%a radius r = 15. The choice of the minimum contrast limit cmin depends on
%the type of imagery and the noise level (cmin = 15 is a suitable value to start
%with).

\subsubsection{Niblackova metóda}
*rovnica vedenia tepla + diskretizacia*
\subsection{Metóda subjektívnych plôch (SUBSURF)}

*POPISAT*

Klasická metóda sujektívnych plôch je definovaná ako

\begin{equation}
u_t = \sqrt{\epsilon^2 + |\nabla u|^2}\nabla.(g \frac{\nabla u}{\sqrt{\epsilon^2 + |\nabla u|^2}}),
\end{equation}

%\begin{equation}
%|\nabla u| = \sqrt{\epsilon^2 + |\nabla u|^2}
%\end{equation}

%kde $u$ 

\begin{equation}
\frac{1}{|\nabla u^{n-1}|_{\epsilon}}.\frac{u^n-u^{n-1}}{\tau} = \nabla.(g^0\frac{\nabla u^n}{|\nabla u^{n-1}|_{\epsilon}}),
\end{equation}

\begin{equation}
\int_{p}\frac{1}{|\nabla u^{n-1}|_{\epsilon}}.\frac{u^n-u^{n-1}}{\tau}dx = \int_{p}\nabla.(g^0\frac{\nabla u^n}{|\nabla u_p^{n-1}|_{\epsilon}})dx,
\end{equation}

Green -$>$
\begin{equation}
\int_{p}\frac{1}{|\nabla u^{n-1}|_{\epsilon}}.\frac{u_p^n-u_p^{n-1}}{\tau}dx = \int_{\partial p} g^0\frac{\nabla u^n}{|\nabla u_p^{n-1}|_{\epsilon}}\vec{n}_pds,
\end{equation}

\begin{equation}
\frac{m(p)}{|\nabla u_p^{n-1}|_{\epsilon}\tau}(u_p^n-u_p^{n-1}) = \sum_{q \in N(p)}\int_{e_{pq}}g_{pq}^0\frac{\nabla u^n}{|\nabla u_{pq}^{n-1}|_{\epsilon}}\vec{n}_{pq}ds,
\end{equation}

\begin{equation}
\frac{m(p)}{|\nabla u_p^{n-1}|_{\epsilon}\tau}(u_p^n-u_p^{n-1}) = \sum_{q \in N(p)}\int_{e_{pq}}g_{pq}^0\frac{u_q^n - u_p^n}{d_{pq}}.\frac{1}{|\nabla u_{pq}^{n-1}|_{\epsilon}}ds,
\end{equation}

\begin{equation}
\frac{m(p)}{|\nabla u_p^{n-1}|_{\epsilon}\tau}(u_p^n-u_p^{n-1}) = \sum_{q \in N(p)}
g_{pq}^0T_{pq}\frac{1}{|\nabla u_{pq}^{n-1}|_{\epsilon}}(u_p^n-u_p^{n-1}),
\end{equation}

\begin{equation}
u_p^n-u_p^{n-1} =\frac{|\nabla u_p^{n-1}|_{\epsilon}\tau}{m(p)} \sum_{q \in N(p)}
g_{pq}^0T_{pq}\frac{1}{|\nabla u_{pq}^{n-1}|_{\epsilon}}(u_p^n-u_p^{n-1}),
\end{equation}

\begin{equation}
u+p^{n-1} = u_p^n + \sum_{q \in N(p)}\frac{|\nabla u_p^{n-1}|_{\epsilon}\tau}{m(p)} \frac{g_{pq}^0T_{pq}}{|\nabla u_{pq}^{n-1}|_{\epsilon}} (u_p^n-u_p^{n-1}),
\end{equation}

\begin{equation}
u+p^{n-1} = (1 + \sum a_{pq})u_p^n -  \sum a_{pq}u_q^n,
\end{equation}



%\newpage
\section{Softvér}

Na implementáciu a vytvorenie prostredia, bol zvolený objektovo orientovaný prístup jazyka C++, spolu s knižnicami Qt, ktoré obsahujú veľa užitočných tried a boli užitočným nástrojom pri vytváraní užívateľského prostredia a VTK knižnicami, ktoré slúžia na zobrazovanie a manipuláciu s dátami.

\subsection{Qt}
Užívateľské rozhranie je vytvorené pomocou Qt knižníc, ktoré sú jedným z najpoužívanejších cross-platformových frameworkov na vytváranie užívateľského prostredia(GUI). Majú aj veľa predprogramovaných knižníc ktoré programátorovi ulahčia prácu. Sú naimplementované v jazyku C++. 

*doplnit ako funguju signaly a sloty*

Najčastejšie využívané Qt knižnice v projekte:
\begin{itemize}
\item \textbf{QMdiArea}\\ 
Táto trieda zohráva jednu z najdôležitejších funkcií v programe. Funkcie tejto triedy fungujú v podstate ako správca okien pre MDI okná, čo v našom prípade znamená, že umožňuje vytvárať podokná pomocou triedy, v ktorých sa v programe nachádzajú ďaľšie Qt triedy slúžíace na vykreslovanie 2D a 3D dát, s ktorými program pracuje. V programe je použité kaskádové usporiadanie takýchto podokien, čo znamená že vykreslovacie okná sa môžu navzájom prekrývať, dajú sa minimalizovať/maximalizovať vrámci hlavného okna a zavrieť.

\item \textbf{QScrollArea} \\
QScrollArea sa nachádza v každom podokne widgetu QMidiArea. Zabezpečuje možnosť priblížiť/oddialiť a posúvať vizualizované dáta.  

\item \textbf{QVTKOpenGLNativeWidget} \\
Widget tejto triedy sa nachádza v každej QScrollAree a umožňuje samotné vykreslenie 2D/3D modelov za pomoci VTK knižníc. 

\item \textbf{QDockWidget} \\
Tento widget obsahuje všetky iformácie a nastavenia súvisiace s dátami. Každý logický celok má vlastný 'dock', ktorý sa dá vrámci okna premiestňovať a ukotvovať buď na ľavej alebo na pravej strane okna. Taktiež sa dajú v prípade potreby minimalizovať.

\item \textbf{QTreeWidget} \\ 
Všetky dáta, či už pôvodné alebo vysegmentované pomocou programe, sa nachádzajú v zozname, z ktorého sa dá vybrať ktoré dáta budú vykreslené. QTreeWidget bol použitý aby sme vykreslované dáta vedeli zadeliť do logických celkov, napríklad či ide o 2D alebo 3D dáta.

\item \textbf{QVector} \\
Trieda QVector definuje dynamické polia, je šablónovou triedou.
%, čo znamená že
Ukladá premenné do susedných miesta v pamäti a poskytuje rýchly indexový prístup. Je použitá v prípadoch keď nie je potrebné odstraňovať prvky zvnútra QVectora.

\item \textbf{QFile, QFileDialog} \\
Tieto triedy slúžia v programe na otváranie, načítavanie, ukladanie a manipuláciu s dátami.

\end{itemize}

\subsubsection{VTK}

Visualization Toolkit (VTK) sú vôľne dostupnými knižnicami, ktoré v programe slúžíia na zobrazovanie a interakciu s 2D aj 3D dátami. Najviac využité knižnice:

\begin{itemize}
\item \textbf{vtkSmartPointer} \\
Táto šablónová trieda, slúži ako pointer nre VTK triedy. Jehou úlohou je zlepšíť manažment s pamäťou, čo znamená, že v prípade ak sú dáta mimo rozsahu alebo sa nikde nepoužívajú tak budú automaticky odstránené. Teda uľahčuje pracovať s dátami bez varovných hlášok.

\item \textbf{vtkPolyData} \\
V objektoch tejto triedy sú zadefinované vykreslované dáta, či už sa jedná o 2D alebo 3D dáta. V tejto triede môžu byť uložené informácie o tom akým spôsobom budú dáta reprezentované - geometrické informácie o štruktúre vykreslovaných dát. Takýmito informáciami môžu byť napríklad body, bunky, vektory, čiary, polygonálne alebo trojuholníkové pásy.

\item \textbf{vtkPolyDataMapper} \\
\item \textbf{vtkActor} \\
\item \textbf{vtkRenderer} \\
\end{itemize}






%\newpage
\section{Výsledky}

%\newpage
\section{Záver}

%\newpage
\begin{thebibliography}{50}
\end{thebibliography}


\end{document}